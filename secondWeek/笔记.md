1. 类**只有**四种成员：成员变量、方法、初始化块、构造器；其他的不属于这些内容的都不是类的成员！比如表达式、赋值语句等等（只能放在方法体或初始化块中）；对应错误提示为：**需要“标识符”**；
2. 一个源文件中最多只允许出现一个public类，且如果存在public类的话，源文件名应与此类名相同；对应错误提示为：**类#是公共的，应在#.java的文件中声明**；

3. 使用package时，用以下命令行编译：

   > javac  -d .  #.java //注意严格格式的遵守 -d 与 .  之间有空格，.  与#.java之间也有空格

   .  表示当前路径，即按当前路径翻译，会在源文件的同级目录下创建此包；

   同时，运行时要在找到类所在路径进行运行，比如（不在原先路径下的类无效）

   > java  com.GDUT.Ayfeier.#   

   对应错误提示为：**找不到或无法加载主类**（当然，这种错误还有可能是环境变量设置出错导致的）；

4. 使用 **+** 作为连接运算符时，如果要使对应类型变量转换成字符串型，直接在print();中输入变量名，如果要与字符或字符串一起输出，使用 **+** 时记得无论是字符或是字符串均要使用**双引号**；若要使布尔类型输出为字符串型，只需在其后加空字符串`""`；

5. foreach 循环：自动遍历数组或集合的每个元素

   > for (type variableName : array | collection)
   >
   > //type 是数组元素和集合元素的类型，variableName是形参名

![foreach](C:\Users\Machenike\Desktop\foreach.PNG)

   使用foreach循环时，通常不要对循环变量进行赋值
6. 想要使用子类时，必须导入子类，而不是单纯导入父类

7. 使用多维数组时，先定义此多维数组（定义数组时是：[ ]...[ ]，不能加长度）；再给最底层的数组元素引用数组

   ![1523601758793](C:\Users\MACHEN~1\AppData\Local\Temp\1523601758793.png)

8. Arrays 类的使用：

   -  `Arrays.equals(String a, String a2);`用于判断两个字符串是否相等；
   -  `Arrays.toString(type[] variableName);`用于转换其他数组类型至字符串；
   -  `Arrays.sort(type[] variableName);`对数组元素（除Boolean外的基本数据类型）进行排序；

9. 异常（Exception）：运行期出现的错误，需要程序员自己检查，作为类包装的对象，出现异常之后，程序就不会继续接下来的操作。

   - 数组越界也属于异常，因为数组越界不会使得编译错误；

   - 常见异常：除0溢出（除以0.0是无穷，不是异常），数组下标越界，读取文件不存在等等；

   - 因为出现异常后会使得程序无法进行下一步，或出现不可预见的结果，所以程序设计时要有异常处理； 

   - 出现异常 -> 抛出异常（throw），系统创建异常类对象 -> 捕捉异常（catch）；

   - > try {
     >
     > ​     异常语句；
     >
     > }catch (type variableName) {      //type 为异常类型，比如ArithmeticException
     >
     > ​     异常处理；
     >
     > }//try 语句与 catch 语句 配合使用，当一个try中有可能出现多个异常的时候，就要使用多个catch
     
   - 当捕捉异常后，程序可以继续运行；
   - finally语句：放在catch语句之后，是无论有无抛出异常，程序都会执行，通常用来进行资源的清除工作，比如关闭打开的文件，删除临时文件等等

![](C:\Users\Machenike\Desktop\secondWeek\Throwable.png)

10. 异常的捕获和处理
  - 捕捉异常后一定要对其进行处理；
  - 自定义异常 ：即自己设置异常类型，而不是直接使用系统默认异常类型；
11. 抽象类与接口的继承：抽象方法必须被重写，且格式一致：参数、名字、返回值；
12. 关于多态：运行时成员变量只有编译类型时的变量，即不具有多态性
   - 继承类：
     父类  variableName = new 子类;
     //该对象不能调用子类中的成员变量，但其子类方法会覆盖父类方法，只有当子类方法中不存在父类中的方法时，父类中的方法才有可能被调用，且不能调用子类特有的方法；（或者可以用super来调用父类中被覆盖的方法）
     class SubClass extends BaseClass {
     	public void text() {
     		super.text();//调用父类中的text方法
     	}
     }
   - 继承接口：当编译类型为接口，运行类型为子类时，只能调用接口中的抽象方法在子类中的改写，子类的特有方法则不能被调用。
13. **容器（集合）**
   - 位于java的工具包中，即`java.util`中
   - collection：
     - Set：无顺序且不可重复；
     - List：有顺序可重复；
     - Map：成对出现（key - value），且key为final类型，不可改变；

